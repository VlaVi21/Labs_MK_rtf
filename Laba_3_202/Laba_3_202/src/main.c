#include <avr/io.h>
#include <avr/delay.h>
#include <avr/interrupt.h>
#include <stdlib.h> //rand

#define BUT1 0x04
#define BUT2 0x08

#define RED 0x80
#define GREEN 0x20
#define BLUE 0x10

int perecl = 0;

//режим зовнішних переривань  для 4 пункту
ISR(INT0_vect)
{	
	/*_delay_ms(15);
	 if((PIND & BUT1) == BUT1) {
		 
		 //пункт 4-6(яркість)
		
		if(OCR2 < 255){
			OCR2 = OCR2 + 5;
		}
		
		
		//ПУНКТ 7
		perecl++;
		if(perecl >+ 8){
			perecl = 8;
		}
	
		switch (perecl){ //пункт 7
			case 1 : //червоний
			OCR2 = 255; // R
			OCR1A = 0; // G
			OCR1B = 0; // B
			break;
			case 2 : //помаранчевий
			OCR2 = 255; // R
			OCR1A = 79; // G
			OCR1B = 0; // B
			break;
			case 3 : // жовтий
			OCR2 = 255; // R
			OCR1A = 255; // G
			OCR1B = 0; // B
			break;
			case 4 : //зелений
			OCR2 = 0; // R
			OCR1A = 255; // G
			OCR1B = 0; // B
			break;
			case 5 : //голубий
			OCR2 = 0; // R
			OCR1A = 141; // G
			OCR1B = 255; // B
			break;
			case 6 : //синій
			OCR2 = 0; // R
			OCR1A = 0; // G
			OCR1B = 255; // B
			break;
			case 7 : //фіолетовий
			OCR2 = 149; // R
			OCR1A = 0; // G
			OCR1B = 255; // B
			break;
			case 8 : //червоний
			OCR2 = 255; // R
			OCR1A = 0; // G
			OCR1B = 0; // B
			break;
		
		}
		while((PIND & BUT1) == BUT1);     
	 }*/
	
}

ISR(INT1_vect)
{
	
	//чому б не обрати case для цього))
	
	/*_delay_ms(15); //це у нас опрацювання кнопки де я або збільшую Яскравість світлодіода саме червоного або зменшую
	if((PIND & BUT2) == BUT2) {
			//пункт 4-6(яркість)
		
		if(OCR2 > 0){ //ми тут або додаємо 5 до 120 і т.д. або віднімаємо
			OCR2 = OCR2 - 5;
		}
		
		
		//ПУНКТ 7
		perecl--;
	
		if(perecl < 1){
			perecl = 1;
		}
		switch (perecl){ //пункт 7
		case 8 : //червоний
		OCR2 = 255; // R
		OCR1A = 0; // G
		OCR1B = 0; // B
		break;
		case 7 : //фіолетовий
		OCR2 = 149; // R
		OCR1A = 0; // G
		OCR1B = 255; // B
		break;
		case 6 : //синій
		OCR2 = 0; // R
		OCR1A = 0; // G
		OCR1B = 255; // B
		break;
		case 5 : //голубий
		OCR2 = 0; // R
		OCR1A = 141; // G
		OCR1B = 255; // B
		break;
		case 4 : //зелений
		OCR2 = 0; // R
		OCR1A = 255; // G
		OCR1B = 0; // B
		break;
		case 3 : //жовтий
		OCR2 = 255; // R
		OCR1A = 255; // G
		OCR1B = 0; // B
		break;
		case 2 : //помаранчевий
		OCR2 = 255; // R
		OCR1A = 79; // G
		OCR1B = 0; // B
		break;
		case 1 : //червоний
		OCR2 = 255; // R
		OCR1A = 0; // G
		OCR1B = 0; // B
		break;
			
		}
		while((PIND & BUT2) == BUT2);     
	}*/
}

void Zavd8(){
	//8 zavd
	// Від червоного до зеленого (зменшуємо червоний, збільшуємо зелений)
	for (int i = 0; i <= 255; i++) {
		OCR2 = 255 - i;   // Червоний зменшується
		OCR1A = i;        // Зелений збільшується
		OCR1B = 0;        // Синій постійно вимкнений
		_delay_ms(8);    // Затримка для плавності
	}

	// Від зеленого до синього (зменшуємо зелений, збільшуємо синій)
	for (int i = 0; i <= 255; i++) {
		OCR2 = 0;         // Червоний вимкнений
		OCR1A = 255 - i;  // Зелений зменшується
		OCR1B = i;        // Синій збільшується
		_delay_ms(8);
	}

	// Від синього до червоного (зменшуємо синій, збільшуємо червоний)
	for (int i = 0; i <= 255; i++) {
		OCR2 = i;         // Червоний збільшується
		OCR1A = 0;        // Зелений вимкнений
		OCR1B = 255 - i;  // Синій зменшується
		_delay_ms(8);
	}

	// І тепер у зворотньому напрямку:

	// Від червоного до синього (зменшуємо червоний, збільшуємо синій)
	for (int i = 0; i <= 255; i++) {
		OCR2 = 255 - i;   // Червоний зменшується
		OCR1A = 0;        // Зелений вимкнений
		OCR1B = i;        // Синій збільшується
		_delay_ms(8);
	}

	// Від синього до зеленого (зменшуємо синій, збільшуємо зелений)
	for (int i = 0; i <= 255; i++) {
		OCR2 = 0;         // Червоний вимкнений
		OCR1A = i;        // Зелений збільшується
		OCR1B = 255 - i;  // Синій зменшується
		_delay_ms(8);
	}

	// Від зеленого до червоного (зменшуємо зелений, збільшуємо червоний)
	for (int i = 0; i <= 255; i++) {
		OCR2 = i;         // Червоний збільшується
		OCR1A = 255 - i;  // Зелений зменшується
		OCR1B = 0;        // Синій вимкнений
		_delay_ms(8);
	}
}

/*void New_year(){ //ефект для нового року(аля новорічна гірлянда з рандомним часом)
	    OCR1A = rand() % 255;    // 0-255, включно
	    OCR1B = rand() % 255;
	    OCR2  = rand() % 255;

	    int randomsTime = 100 + (rand() % 900); // 100..999 мс
	    for (int i = 0; i < randomsTime; i++) {
		    _delay_ms(1);
	    }
}*/

/*void Glory_to_Ukraine(){
	  // Спочатку синій дихає (верхня половина прапора)
	  for (int i = 0; i < 255; i++) {
		  OCR1B = i;    // Синій збільшується
		  _delay_ms(2);
	  }
	  for (int i = 255; i > 0; i--) {
		  OCR1B = i;    // Синій зменшується
		  _delay_ms(2);
	  }

	  // Потім жовтий дихає (жовтий = червоний + зелений)
	  for (int i = 0; i < 255; i++) {
		  OCR2  = i;    // Червоний
		  OCR1A = i;    // Зелений
		  _delay_ms(2);
	  }
	  for (int i = 255; i > 0; i--) {
		  OCR2  = i;    // Червоний
		  OCR1A = i;    // Зелений
		  _delay_ms(2);
	  }
}*/

int main (void)
{
	//згідно даташиту(ст. 105)
	TCCR2 |= (1<<WGM20)|(1<<WGM21)|(1<<COM21)|(1<<CS22); //налаштування таймера ШІМ
	         //((1<<WGM20)|(1<<WGM21)) - Установлюють режим Fast PWM (режим швидкої ШІМ), де таймер працює від 0 до 255
		     //(COM21) - Установлює режим "Clear OC2 on compare match" (очищення виводу OC2 при співпадінні), що потрібно для ШІМ на виводі OC2 (PD7).
			 //(CS22) - Установлює переддільник частоти таймера на 64, що визначає частоту ШІМ.

	//Налаштування Timer/Counter 1 (Fast PWM, 8-bit, TOP = 0x00FF)
	TCCR1A |= (1 << WGM10) | (1 << COM1A1) | (1 << COM1B1);
	//(TCCR1A - Регістр керування таймером 1)
	//(WGM10- Біт режиму хвилі (Waveform Generation Mode). У комбінації з WGM12 (нижче) встановлює Fast PWM, 8-біт (TOP = 0x00FF))
	//(COM1A1: Налаштовує вивід OC1A (PB1) на "очищення при співпадінні" (неінвертований ШІМ: вивід HIGH на початку циклу, LOW при досягненні OCR1A))
	//І логічно, COM1B1 теж налаштовує відповідний вивід OC1B як і COM1A1
	TCCR1B |= (1 << WGM12) | (1 << CS10); // Fast PWM, без переддільника, тут ми обираємо режим і частоту таймера
			  //(1 << WGM12) - Доповнює WGM10 для режиму Fast PWM, 8-біт (TOP = 0x00FF)
							//(1 << CS10) - Встановлює переддільник = 1, частота 16 МГц для таймера

	//OCR1A = 27;  // Максимальна ширина імпульсу для (червоний) - тут у нас регістр порівняння для каналу А, тобто червоний світлодіод, максимум як в завданні 0x00FF
	//OCR1B = 0;  // Максимальна ширина імпульсу для (зелений) - тут відповідно В
	//225 у 8-біт реж. (0x00FF) - це 255
	
    //налаштування переривань
	MCUCR |= (1 << ISC00) | (1 << ISC01); // переривання на зростаючому фронті сигналу (тобто, коли кнопка натиснута й сигнал переходить із LOW до HIGH).
	MCUCR |= (1 << ISC10) | (1 << ISC11);
	GICR |= (1 << INT0) | (1 << INT1); //вмикаємо самі переривання
	sei();
	
	DDRD = 0xB0; //регістр, який вставновлює біти PD7 (OC2, вихід ШІМ), PD6 і PD5 як виходи (1), а решта бітів (включаючи PD2 і PD3 для кнопок) залишаються входами (0)
	
	//пункт 5
	//OCR2 = 120; //OCR2 = 120 (пункт 3-4);
	//OCR1A = 255;
	//OCR1B = 255;
	 
	//пункт 6, обираю свій улюблений синій колір, це у форматі RGB 0, 27, 253 https://findh.org/5060-konverter-tsvetov.html
	/*OCR2 = 0; // R
	OCR1A = 27; // G
	OCR1B = 253; // B*/
	
	
	-

	while(1){
		Zavd8();
		//New_year();
		//Glory_to_Ukraine();
	}
}


//Шим це імпульсний сигнал постійної частоти зі змінним коефіцієнтом заповнення
//Коеф заповнення це відношення імпульсу до періоду
